---
title: "FSCI 2024 Analysis"
author: "Kate Schneider Lecy"
date: "`r Sys.Date()`"
output: html_document
---

### *Overall Objectives*
This script contains all analysis tables and figures for the 2025 FSCI paper.

```{r setup, warning = FALSE, messages = FALSE, results = "hide", echo = TRUE}
### Setup required to knit this script into a markdown document
    
### Load packages
    # R studio should prompt the installation of any packages not loaded on the instance where this script has been opened
    
    # Data management and multipurpose packages
    library(kableExtra)
    library(knitr)
    library(tidyverse)
    library(stats)
    library(broom)
    library(here)

    # Data visualization packages
    library(cowplot)
    library(flextable)

### File management
  
    # Set the root folder to the project root so that all file paths are relative to the main project folder
    knitr::opts_knit$set('./')
    
    # Set relative directory paths
    data_out <- here::here("Output data")
    figtab_out <- here::here("Figures & Tables")

### Set preferred options
    
    # Set the treatment of numbers to numerical (avoids scientific notation from showing in results)
    options(scipen = 999)
  
    # Set echo = FALSE for all code chunks will prevent the code from printing in the output file as the default setting (set to TRUE where relevant)
    knitr::opts_chunk$set(echo = FALSE)

### Functions
    
    # Create a "not in" operator
    `%notin%` <- Negate(`%in%`) 
    
### Color palettes
    themes_colors <- c("#21908dff", "#3b518bff", "#97a4b2", "#fde725ff", "#5cc863ff")
    categories <- c("#97ebdb", "#0086ad", "#005582", "gray80")
    income_colors <- c("Low income" = "#97a4b2", 
                      "Lower middle income"  = "#41B6C4", 
                      "Upper middle income" = "#1D91C0", 
                      "High income" = "#0C2C84",
                      "Global mean" = "gray25")
    region_colors <- c("Central Asia" = "#CC6677FF",
                      "Eastern Asia" = "#332288FF",                  
                      "Latin America & Caribbean" = "#DDCC77FF",     
                      "Northern Africa & Western Asia" = "#117733FF", 
                      "Northern America and Europe" = "#88CCEEFF",    
                      "Oceania" = "#882255FF",
                      "South-eastern Asia" =  "#44AA99FF",            
                      "Southern Asia" = "#999933FF",                  
                      "Sub-Saharan Africa" = "#AA4499FF",
                       "Global mean" = "gray25")

    
### Organization
    col_order <- c("country", "M49_code", "ISO3", "indicator", 
           "year", "value", "unit")
    row_order <- c("country", "year", "variable_order")
```

#### Load data files
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Supplementary data file 1: "Supplementary Data 1 - Metadata and Codebook.xlsx" contained in root R project folder. This is an Excel workbook best viewed in Excel and provides metadata for reference.

# Supplementary data file 3:
FSCI_2025 <- readRDS(file = file.path(data_out, "FSCI_2025.rds"))

# Supplementary data file 4:
load(file = file.path(data_out, "Performance_Metrics.RData"))

```

$~$

# Main manuscript figures

#### Figure 1. 
```{r, warning = FALSE, messages = FALSE, cache = TRUE}

# Save as png
    png(file.path(figtab_out, "Figure 1.png"), width = 7.5, height = 10)
    # Code
    dev.off()

# Save as pdf
    pdf(file.path(figtab_out, "Figure 1.pdf"), width = 7.5, height = 10)
    # Code
    dev.off()

# Clean up
  rm()

```


$~$

#### Figure 2. 
```{r, warning = FALSE, messages = FALSE, cache = TRUE}

# Save as png
    png(file.path(figtab_out, "Figure 2.png"), width = 7.5, height = 10)
    # Code
    dev.off()

# Save as pdf
    pdf(file.path(figtab_out, "Figure 2.pdf"), width = 7.5, height = 10)
    # Code
    dev.off()

# Clean up
  rm()

```

$~$

#### Figure 3. 
```{r, warning = FALSE, messages = FALSE, cache = TRUE}

# Save as png
    png(file.path(figtab_out, "Figure 3.png"), width = 7.5, height = 10)
    # Code
    dev.off()

# Save as PDF for journal
    pdf(file.path(figtab_out, "Figure 3.pdf"), width = 7.5, height = 10)
    # Code
    dev.off()

  
# Clean up
  rm()
  
```

$~$

#### Figure 4
```{r, warning = FALSE, messages = FALSE, cache = TRUE}

# Save as png
  png(file.path(figtab_out, "Figure 4.png"), width = STD_WIDTH, height = 7.5, unit = "in", res = 300)
    # Code
  dev.off()
  
# Save as pdf
  pdf(file.path(figtab_out, "Figure 4.pdf"), width = 10, height = 7.5)
    # Code
  dev.off()


# Clean up
  rm()

```

$~$

# Extended Data

$~$

#### Extended Data Tables X and X
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Create data frame with latest data point per country-indicator
# Only includes data since 2010 for realistic relevance to current situation. 
  latest_df <- FSCI_2025 %>%
    filter(!(is.na(value))) %>%
    filter(!(is.na(weight))) %>%
    filter(year >= 2010) %>%
    group_by(country, indicator) %>%
    mutate(maxyear = max(year)) %>%
    filter(year == maxyear) %>%
    ungroup() %>%
  unique()

# Multiply the damages indicator by 100 for display purposes (else it rounds to 0 when printing table with one significant digit)
latest_df <- latest_df %>%
  mutate(value = as.numeric(value),
         value = case_when(indicator == "Ratio of total damages from all disasters to GDP" ~ value * 1000,
                           TRUE ~ value))

# Recalculate weighted means
  # Remove annually calculated variables
    latest_df <- latest_df %>%
      select(-c(ends_with("mean")))

    # Compute new weighted means
    globalmeans <- latest_df %>%
      arrange(indicator) %>%
      filter(!(unit == "categorical")) %>%
      mutate(value = as.numeric(value)) %>%
      filter(!(is.na(value))) %>%
      # Global mean
        group_by(indicator) %>%
        filter(!(is.na(value))) %>%
        filter(!(is.na(weight))) %>%
        mutate(globalmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
      select(c(4, 41)) %>%
      unique()
    
      # Regional mean
      regionmeans <- latest_df %>%
        arrange(indicator, FSCI_region) %>%
        filter(!(unit == "categorical")) %>%
        filter(!(is.na(FSCI_region))) %>%
        mutate(value = as.numeric(value)) %>%
        filter(!(is.na(value))) %>%
        group_by(indicator, FSCI_region) %>%
        mutate(regionmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
        select(c(4,18,41)) %>%
        unique()

      # Income group mean
      incomemeans <- latest_df %>%
        arrange(indicator, income_group) %>%
        filter(!(unit == "categorical")) %>%
        filter(!(is.na(income_group))) %>%
        mutate(value = as.numeric(value)) %>%
        filter(!(is.na(value))) %>%
        group_by(indicator, income_group) %>%
        mutate(incomegrpmean = stats::weighted.mean(value, weight, na.rm = TRUE)) %>%
        ungroup() %>%
        select(c(4,17,41)) %>%
        unique()

# Merge back into the dataset
    latest_df <- left_join(latest_df, globalmeans, by = "indicator")
    latest_df <- left_join(latest_df, regionmeans, by = c("indicator", "FSCI_region"))
    latest_df <- left_join(latest_df, incomemeans, by = c("indicator", "income_group"))
    
# Now keep only one row per indicator with the metadata and means
    latest_df <- latest_df %>%
      select(c("indicator", "short_label", "theme", "domain", "unit", "FSCI_region", "income_group", "mean_weighting", "desirable_direction", ends_with("mean")), "indicator_order") %>%
      unique() %>%
      rename(Indicator = indicator,
             Unit = unit,
             Theme = theme,
             Domain = domain,
             "Desirable direction of change" = desirable_direction,
             "Global mean" = globalmean) %>%
      mutate(mean_weighting = case_when(mean_weighting == "agland" ~ "Agricultural land area",
                                        mean_weighting == "agland_ESA" ~ "Agricultural land area - ESA",
                                        mean_weighting == "agland_minspecies" ~ "Agricultural land area - Minimum species richness",
                                       str_detect(mean_weighting, "^animals") ~ "Producing animals",
                                       str_detect(mean_weighting, "^areaharvested") ~ "Area harvested",
                                       str_detect(mean_weighting, "^production") ~ "Total production",
                                       mean_weighting == "cropland" ~ "Cropland",
                                       mean_weighting == "landarea" ~ "Land area",
                                       mean_weighting == "pop_u" ~ "Urban population",
                                       mean_weighting == "totalpop" ~ "Total population",
                                       mean_weighting == "unweighted" ~ "Unweighted",
                                       TRUE ~ mean_weighting)) %>%
      rename('Weighted by' = mean_weighting)
    
# Income group and metadata table
    inc_meta_tbl <- latest_df %>%
      select(-c("FSCI_region", "regionmean")) %>%
      unique() %>%
      filter(!(is.na(income_group))) %>%
      pivot_wider(names_from = income_group, values_from = incomegrpmean) %>%
      arrange(indicator_order) %>%
      select(-c(indicator_order, short_label)) %>%
      relocate('Global mean', .after = 'High income') %>%
      relocate('Upper middle income', .after = 'Lower middle income') %>%
      relocate(Indicator, .after = Domain) %>%
      mutate(across(7:11, round, 1))
    
    flextable::set_flextable_defaults(
      font.family = 'Times New Roman',
      font.size = 10)
    table1 <- flextable::flextable(inc_meta_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(table1, path = file.path(figtab_out, "ED Table X_Inc Group + Metadata.docx"), orient = "landscape")
      
# Regional means table
    regions_tbl <- latest_df %>%
      select(-c("income_group", "incomegrpmean")) %>%
      unique() %>%
      filter(!(is.na(FSCI_region))) %>%
      pivot_wider(names_from = FSCI_region, values_from = regionmean) %>%
      arrange(indicator_order) %>%
      select(-c(indicator_order, Indicator)) %>%
      relocate('Global mean', .after = 'Central Asia') %>%
      relocate(short_label, .after = Domain) %>%
      mutate(across(7:16, round, 1)) %>%
      rename('Indicator' = short_label)
    
    table2 <- flextable::flextable(regions_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(table2, path = file.path(figtab_out, "ED Table X_Regional Means.docx"), orient = "landscape")
      
# Clean up
  rm(latest_df, globalmeans, incomemeans, regionmeans,inc_meta_tbl, regions_tbl, table1, table2)
```



$~$

# Supplementary Information

$~$

#### Figure SI X. Trends over time
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Regress each variable on time to get average linear trend

# Indicators that must be excluded from time trend regression:
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Unhealthy foods")
  
  # Set up data
    data <- FSCI_2025 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now normalize the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)
    
    # Initialize an empty list to store results
      results_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- filter(data, short_label == i)
        
        # Check if there are enough data points for the model
          print(i)

          model <- lm(normvalue ~ year + FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          result <- result

          # Add 95% confidence interval to the result
          conf_int <- broom::confint_tidy(model)

          result <- cbind(result, conf_int)
          
          # Add short_label to the result
          result$short_label <- i
          
          # Add result to list
          results_list[[i]] <- result 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
    
# Export table of full results
    
    regress_tbl <- all_results %>%
      filter(term != "(Intercept)") %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      select(-c(statistic, term)) %>%
      mutate(across(1:5, round, 5)) %>%
      relocate(short_label, .before = estimate)
    
    # Add indicator order to sort
    data2 <- data[, c("short_label", "indicator_order", "desirable_direction")]
    data2 <- data2 %>% unique()
    regress_tbl <- left_join(regress_tbl, data2, by = ("Indicator" = "short_label"))
    regress_tbl <- regress_tbl %>% arrange(indicator_order) %>%
      select(-c(indicator_order))
    
    # Name the columns nicely
    col_names <- c( "Indicator", "Coef.", "SE", "p val.", "95% Conf. Int.", "merge", "Desirable direction")
    colnames(regress_tbl) <- col_names
    
# Remove the intercepts
    all_results2 <- all_results %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      filter(term != "(Intercept)") %>%
      rename(pval = "p.value")
    
# Add stars for p-value
    all_results2 <- all_results2 %>%
      mutate(star = case_when(pval < 0.001 ~ "***",
                              pval >= 0.001 & pval < 0.01 ~ "**",
                              pval >= 0.01 & pval < 0.05 ~ "*",
                              pval >= 0.05 ~ "")) %>%
      select(short_label, estimate, conf.low, conf.high, star, pval) %>%
      mutate(across(2:4, round, 3)) # This rounding step is consequential for the results - important to make a choice about how many digits to keep to "round to zero"
    
    # Merge in the theme and variable order 
    data2 <- data[, c("short_label", "indicator_order", "theme", "desirable_direction")]
    data2 <- data2 %>% unique()
    all_results2$short_label <- factor(all_results2$short_label)
    all_results2 <- left_join(all_results2, data2, by = c("short_label"))
    # Add a variable to indicate whether the change is flat, in the right direction, or in the wrong direction
    all_results2 <- all_results2 %>%
      mutate(Progress = case_when(pval >= 0.05 ~ "No change",
                                  desirable_direction == 1 & pval < 0.05 & estimate > 0 ~ "Desirable change",
                                  desirable_direction == -1 & pval < 0.05 & estimate < 0 ~ "Desirable change",
                                  desirable_direction == 1 & pval < 0.05 & estimate < 0 ~ "Undesirable change",
                                  desirable_direction == -1 & pval < 0.05 & estimate > 0 ~ "Undesirable change",
                                  desirable_direction == 1 & pval <0.05 & estimate == 0 ~ "No change",
                                  desirable_direction == -1 & pval <0.05 & estimate == 0 ~ "No change",
                                  TRUE ~ "No change"),
             Progress = as.factor(Progress))


# Plot the estimates
  p1 <- all_results2 %>%
       filter(estimate < 11) %>%
      ggplot(., aes(y = fct_reorder(short_label, desc(estimate)), x = estimate)) + 
      geom_point(aes(color = Progress)) +
      geom_errorbarh(aes(xmin = conf.low, xmax = conf.high, color = Progress), width = 0.1) +
      geom_text(aes(label = star, x = conf.high, color = Progress), hjust = -.1) +
      scale_color_manual(values = c("forestgreen","gray85",  "darkred")) +
      scale_y_discrete(limits=rev) +
      geom_vline(xintercept = 0) +
      theme_classic() +
      labs(y = "",
           x = "Average percent change per year (95% Confidence Interval)",
           caption = "*** p< 0.001, ** p< 0.01, * p < 0.05") +
      theme(plot.caption = element_text(hjust = -0.88),
            plot.margin = unit(c(0,0,0,0), "cm"),
            legend.position = "none")

  # Now create the legend to show progress
    forlegend <- all_results2 %>%
      ggplot(., aes(y = fct_reorder(short_label, desc(estimate)), x = 1)) +
      geom_point(aes(color = Progress), size = 4) +
      scale_color_manual(values = c( "forestgreen","gray85", "darkred"),
                         guide = guide_legend()) +
      scale_y_discrete(limits=rev) +
      scale_x_discrete(c(1,1)) +
      theme_classic() +
      theme(legend.text = element_text(size=12),
            legend.title.align = 0,
            legend.position = "right", 
            legend.justification = "left",
            legend.direction = "horizontal",
            legend.title = element_text(size=12),
            plot.margin = unit(c(0,0,0,0), "cm"),
            legend.margin=unit(c(0,0,0,0), "cm"))
    legend <- get_legend(forlegend)

# Save the plot as .png
#     png(file.path(figtab_out, "SI Figure X_Trends.png"), width = 7.5, height = 10, unit = "in", res = 300)
     cowplot::plot_grid(p1, legend, nrow = 2, rel_heights = c(22,1), align = "v")
#     dev.off()
#     
# # And as PDF for journal
#     pdf(file.path(figtab_out, "SI Figure X_Trends.pdf"), width = 7.5, height = 10)
    cowplot::plot_grid(p1, legend, nrow = 2, rel_heights = c(22,1), align = "v")
#     dev.off()

# Clean up
  rm(legend, p1, all_results2, data2, col_names, regress_tbl, all_results, data, surveyindicators, oneyear, Indicator, i, model, conf_int)  
  
```


#### SI Table X. Regression results of time trends
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Regress each variable on time to get average linear trend

# Indicators that must be excluded from time trend regression:
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Unhealthy foods")
  
  # Set up data
    data <- FSCI_2025 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now normalize the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)
    
    # Initialize an empty list to store results
      results_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- filter(data, short_label == i)
        
        # Check if there are enough data points for the model
          print(i)

          model <- lm(normvalue ~ year + FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          result <- result

          # Add 95% confidence interval to the result
          conf_int <- broom::confint_tidy(model)

          result <- cbind(result, conf_int)
          
          # Add short_label to the result
          result$short_label <- i
          
          # Add result to list
          results_list[[i]] <- result 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
    
    regress_tbl <- all_results %>%
      filter(term != "(Intercept)") %>%
      filter(!str_detect(term, "^FSCI_region")) %>%
      select(-c(statistic, term)) %>%
      mutate(across(1:5, round, 5)) %>%
      relocate(short_label, .before = estimate)
    
    # Add indicator order to sort
    data2 <- data[, c("short_label", "indicator_order", "desirable_direction")]
    data2 <- data2 %>% unique()
    regress_tbl <- left_join(regress_tbl, data2, by = ("Indicator" = "short_label"))
    regress_tbl <- regress_tbl %>% arrange(indicator_order) %>%
      select(-c(indicator_order))
    
    # Add stars for p-value
    regress_tbl <- regress_tbl %>%
      mutate(star = case_when(p.value < 0.001 ~ "***",
                              p.value >= 0.001 & p.value < 0.01 ~ "**",
                              p.value >= 0.01 & p.value < 0.05 ~ "*",
                              p.value >= 0.05 ~ "")) %>%
      mutate(across(2:6, round, 3)) %>% # This rounding step is consequential for the results - important to make a choice about how many digits to keep to "round to zero"
      relocate(star, .after = p.value)
    
  
    # Add progress column
    regress_tbl <- regress_tbl %>%
      mutate(Progress = case_when(p.value >= 0.05 ~ "No change",
                                  desirable_direction == 1 & p.value < 0.05 & estimate > 0 ~ "Desirable change",
                                  desirable_direction == -1 & p.value < 0.05 & estimate < 0 ~ "Desirable change",
                                  desirable_direction == 1 & p.value < 0.05 & estimate < 0 ~ "Undesirable change",
                                  desirable_direction == -1 & p.value < 0.05 & estimate > 0 ~ "Undesirable change",
                                  desirable_direction == 1 & p.value <0.05 & estimate == 0 ~ "No change",
                                  desirable_direction == -1 & p.value <0.05 & estimate == 0 ~ "No change",
                                  TRUE ~ "No change"),
             Progress = as.factor(Progress))
    
  # Get the sample size (countries by years) per indicator
    samplesize <- data %>%
      group_by(short_label) %>%
      summarize("N countries" = n_distinct(country),
                "Years" = min(year),
                "Years2" = max(year),
                "N years" = n_distinct(year)) %>%
      ungroup()
    regress_tbl <- left_join(regress_tbl, samplesize, by = c("short_label"))
    
    # Name the columns nicely
    col_names <- c( "Indicator", "Coef.", "SE", "p val.", "merge1", "95% Conf. Int.", "merge2", "Desirable direction", "Trend", "N Countries", "Years", "merge3", "N years")
    colnames(regress_tbl) <- col_names
    regress_tbl$Years <- as.character(regress_tbl$Years)
    regress_tbl$merge3 <- as.character(regress_tbl$merge3)
    

# Export table of full results
    
    SItable1 <- flextable::flextable(regress_tbl) %>% autofit() %>%
      set_table_properties(layout = "autofit")
        
    # Save table
      save_as_docx(SItable1, path = file.path(figtab_out, "SI Table X_Linear time trend regression.docx"), orient = "landscape")
      
# Clean up
    rm(surveyindicators, oneyear, SItable1, regress_tbl, data2, all_results, results_list, data)

# Create table
  flextable::flextable(table) %>%
    save_as_docx(path = file.path(figtab_out, "SI Table X.docx"))
  
# Clean up
  rm()
      
```

$~$

#### SI Table X - Imputed food price index observations dropped 
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
  # Load the raw food price data
      temp_env <- new.env()
      load(file.path(data_in, "APIpulls_21Feb2025.RData"), envir = temp_env)
      result_fpi <- temp_env$result_fpi
      rm(temp_env)
      fpi_imputed <- as.data.frame(result_fpi) 
      
    # Check the imputed records
      fpi_imputed <- fpi_imputed %>%
        filter(Flag.Description == "Imputed value") %>%
        mutate(across(everything(), ~ as.numeric(.))) %>%
        mutate(Year = as.Date(Year, format = "%Y"))

          # Add ISO codes and get correct UN country name
            fpi_imputed$ISO3 <- countrycode::countrycode(fpi_imputed$Area.Code..M49., origin = 'un', destination = 'iso3c', warn = TRUE, nomatch = NA)
            fpi_imputed$Country <- countrycode::countrycode(fpi_imputed$ISO3, origin = 'iso3c', destination = 'un.name.en', warn = TRUE, nomatch = NA)  

      # Summary 
      summary(fpi_imputed$Year)
      unique(fpi_imputed$Country)
      fpi_imputed_sum <- fpi_imputed %>% group_by(Country, Year) %>%
        summarise(N_imputed = n(), .groups = "drop") %>%
        pivot_wider(names_from = Year, values_from = N_imputed) 
      
# Create table
  SItable_X <- flextable::flextable(fpi_imputed_sum)
  flextable::flextable(table) %>%
    save_as_docx(path = file.path(figtab_out, "SI Table 2.docx"))
  
# Clean up
  rm(result_fpi, fpi_imputed, fpi_imputed_sum, SItable_X)
      
```

$~$


#### SI FIgures X-X Time trends by region
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Indicators that must be excluded from time trend regression:
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Dietary moderation")
  
  # Set up data
    data <- FSCI_2025 %>%
      # Remove categorical indicators
      filter(!(unit == "categorical")) %>%
      # Remove indicators with only one year of data
      filter(!(short_label %in% oneyear)) %>%
      # Remove survey data
      filter(!(short_label %in% surveyindicators)) %>%
      select(country, short_label, year, value, indicator_order, 
             desirable_direction, theme, weight, 
             FSCI_region, income_group) %>%
      filter(!(is.na(value))) %>%
      mutate(value = as.numeric(value),
             country = as.character(country)) %>%
      ungroup() %>%
      filter(!(is.na(value)))
    
  # Now normalize the data
    data <- data %>%
      group_by(short_label) %>%
      mutate(normvalue = (value - min(value)) / (max(value) - min(value)),
             normvalue = normvalue * 100) %>%
      ungroup() 
    
    data$short_label <- factor(data$short_label)
    data$country <- factor(data$country)
    data <- droplevels(data)

    # Initialize an empty list to store results
      results_list <- list()
      predict_list <- list()

    # Iterate over unique levels of short_label
      for (i in unique(data$short_label)) {
        dat <- data %>% filter(short_label == i)
        
        # Check if there are enough data points for the model
          model <- lm(normvalue ~ year*FSCI_region, data = dat, weights = weight)
          result <- broom::tidy(model)
          predict <- ggeffects::ggpredict(model, c("year", "FSCI_region"))

          # Add short_label to the result
          result$short_label <- i
          predict$short_label <- i

          # Add result to list
          results_list[[i]] <- result 
          predict_list[[i]] <- predict 
          }
    
    # Combine results into a single data frame
    all_results <- do.call(rbind, results_list)
    margins <- do.call(rbind, predict_list)
    
    # Bring in theme
    data2 <- data[, c("short_label", "indicator_order", "theme", "desirable_direction")]
    data2 <- data2 %>% unique()
    margins$short_label <- factor(margins$short_label)
    margins <- left_join(margins, data2, by = c("short_label"))
    # Clean up 
    margins <- margins %>%
      rename(Year = x,
             y_hat = predicted,
             SE = std.error,
             Region = group)
      
    marginsplot <- function(data, label) {
        p <- margins%>% 
          filter(margins$short_label == label) %>%
          ggplot(aes(x = as.factor(Year), y = y_hat, color = Region)) +
          geom_point(size = 1) +
          geom_line(aes(group = Region), size = 1) +
          scale_color_manual(values = region_colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_text(size = 7),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          labs(y = "Predicted value (% change)") +
          ggtitle(label) 
      print(p)
    }

  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Plot per theme
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, data  %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label)) %>%
             droplevels()) 
    ordered_indicators <- get(df)$short_label
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) marginsplot(df_1, x)) 
    plots_2 <- lapply(indicators_2, function(x) marginsplot(df_2, x)) 
    plots_3 <- lapply(indicators_3, function(x) marginsplot(df_3, x)) 
    plots_4 <- lapply(indicators_4, function(x) marginsplot(df_4, x)) 
    plots_5 <- lapply(indicators_5, function(x) marginsplot(df_5, x))
  
# Set up a figure for the legend
    forlegend <- function(data, label) {
        p <- margins%>% 
          filter(margins$short_label == label) %>%
          ggplot(aes(x = as.factor(Year), y = y_hat, color = Region)) +
          geom_point(size = 1) +
          geom_line(aes(group = Region), size = 1) +
          scale_color_manual(values = region_colors) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_text("Predicted outcome"),
                axis.text.x = element_blank(),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=7),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(label) 
      print(p)
    }
  for_legend <- lapply(indicators_5, function(label) forlegend(df_5, label))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure X_Theme1_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme2_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme3_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme4_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme5_trendlines.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(17,1), align = "hv")
      dev.off()

  # Clean up
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
    }


# Clean up
    rm(all_results, p1,p2,p3,p4,top,bottom,forlegend, legend, oneyear, dat, data2, for_legend, model, predict, predict_list, result, results_list, margins)

```

$~$

#### SI Figures X-XX: All data with the global weighted mean by thematic area
Graphs over time - all country level data points
Note: where there are points in 2022-2024 with no global mean, it is because there is no data for the weighting variable available yet for that year.

This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
 # Make the global mean into a row to visualize "as a country"
    data <- FSCI_2025 %>%
      filter(!(unit == "categorical")) %>%
      mutate(value = as.numeric(value)) %>%
      select(c(country, country_order, value, indicator, year, unit, variable, short_label, variable_order, theme, domain, desirable_direction, globalmean))

    globalmean <- data %>%
      select(-c(country, country_order, value)) %>%
      mutate(value = globalmean,
             country = "Global weighted mean",
             country_order = 195,
             M49_code = "",
             ISO3 = "") %>%
      unique() 
   globalmean <- globalmean[, c("country", "country_order", "value", "indicator", "year", "unit", "variable", "short_label", "variable_order", "theme", "domain", "desirable_direction", "globalmean")]
   
    data <- data  
    # Bind rows
      data <- rbind(data, globalmean)
    
  # Remove global weighted mean for indicators where there are different countries shown per year
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Dietary moderation")
    data <- data %>%
      mutate(value = case_when(short_label %in% surveyindicators & country == "Global weighted mean" ~ NA, 
                               TRUE ~ value))
      
  # Organize
    data <- droplevels(data)
    data <- data %>% arrange(indicator, year, country_order) 
    data$short_label <- as.character(data$short_label)
    data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))
    
  # Plot
    plotdot <- function(data, x) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(country_order, year) %>%
          ggplot(aes(x = year, y = value, group = country)) +
          geom_point(aes(color = country)) + 
          scale_color_manual(values = ifelse(data$country == "Global weighted mean",
                                              "maroon", "lightgray")) +
          guides(color = guide_none()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8),
                plot.subtitle = element_text(size = 7, color = "black")) +
          labs(title = x) 
    }

  # Plot per theme
    n <- 1
      for (i in levels(data$theme)) {
        df <- paste0("df_", n)  
        assign(df, data %>%
                 filter(theme == i) %>%
                 mutate(indicator = as.factor(indicator),
                        year = as.factor(year)) %>%
                 droplevels() %>%
                 arrange(indicator, year, country_order)) 
        ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$variable_order)
        ind <- paste0("indicators_", n)  
        assign(ind, as.list(levels(ordered_indicators)))
        n <- n + 1
        }
      
      plots_1 <- lapply(indicators_1, function(x) plotdot(df_1, x)) 
      plots_2 <- lapply(indicators_2, function(x) plotdot(df_2, x)) 
      plots_3 <- lapply(indicators_3, function(x) plotdot(df_3, x)) 
      plots_4 <- lapply(indicators_4, function(x) plotdot(df_4, x)) 
      plots_5 <- lapply(indicators_5, function(x) plotdot(df_5, x)) 

  # Set up a figure for the legend
  forlegend <- function(data, x) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(country_order, year) %>%
          ggplot(aes(x = year, y = value, group = country)) +
          geom_point(aes(color = country), size = 3) + 
          scale_color_manual(values = ifelse(data$country == "Global weighted mean",
                                              "maroon", "lightgray"),
                             labels = c("Country data point", "Global weighted mean")) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_blank(),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=9),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank())
    }
                
  df_2_leg <- df_2 %>% filter(country == "Italy" | country == "Global weighted mean")
  for_legend <- lapply(indicators_2, function(x) forlegend(df_2_leg, x))
  legend <- get_legend(for_legend[[7]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure X_Theme1 all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme2  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme3  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme4  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme5  all data.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()

  # Clean up
    rm(ordered_indicators, indicators, forpaper, data, data2, plots, df_2_leg, legend, for_legend, globalmean, globalmeans)
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }

    }

```


#### SI Figures X-XX: Data points by region
This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Set up the data with only aggregate values
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Dietary moderation")

  data <- FSCI_2025 %>%
    filter(!(unit == "categorical")) %>%
    filter(!(is.na(indicator_order))) %>%
    # Eliminate survey indicators
    filter(!(short_label %in% surveyindicators)) %>%
    select(c(desirable_direction, year, short_label, indicator_order, regionmean, FSCI_region, incomegrpmean, income_group, globalmean, theme)) %>% unique() %>%
    arrange(indicator_order, year) %>%
    mutate(year = as.factor(year)) %>%
    rename('Global mean' = globalmean)
  data <- droplevels(data)
  data$short_label <- factor(data$short_label)
  data <- data %>% droplevels()
  
  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Regional means data
    regions <- data %>%
      select(-c("income_group", "incomegrpmean")) %>%
      unique() %>%
      filter(!(is.na(FSCI_region))) %>%
      pivot_wider(names_from = FSCI_region, values_from = regionmean) %>%
      arrange(indicator_order) %>%
      relocate('Global mean', .after = 'Central Asia') %>%
      pivot_longer(6:15, names_to = "group", values_to = "value")
    regions <- droplevels(regions)
    regions$group <- factor(regions$group)

# Plot function
    plotlines <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          ggtitle(x) 
      print(p)
    }
    
# Run for all indicators   
  ordered_indicators <- fct_reorder(data$short_label, data$indicator_order)
  indicators <- as.list(levels(ordered_indicators))
  lapply(indicators, function(x) plotlines(regions, x, region_colors))  

# Plot per theme - income
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, regions %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label),
                    year = as.factor(year)) %>%
             droplevels() %>%
             arrange(short_label, year, group)) 
    ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$indicator_order)
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) plotlines(df_1, x, region_colors)) 
    plots_2 <- lapply(indicators_2, function(x) plotlines(df_2, x, region_colors)) 
    plots_3 <- lapply(indicators_3, function(x) plotlines(df_3, x, region_colors)) 
    plots_4 <- lapply(indicators_4, function(x) plotlines(df_4, x, region_colors)) 
    plots_5 <- lapply(indicators_5, function(x) plotlines(df_5, x, region_colors))
  
# Set up a figure for the legend
  forlegend <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = guide_legend(nrow=2)) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=8),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(x) 
      print(p)
  }
  for_legend <- lapply(indicators_5, function(x) forlegend(df_5, x, region_colors))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')

  png(file.path(figtab_out, "SI Figure X_Theme1_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
  png(file.path(figtab_out, "SI Figure X_Theme2_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme3_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme4_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme5_region.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(18,1), align = "hv")
  dev.off()

  # Clean up
    rm(up, down, ordered_indicators, indicators, forpaper, data, data2, plots, for_legend, legend, regions)
    for (i in 1:9) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
       if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
     if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      
    }

```


#### SI Figures X-XX: Data points by income group
This code creates one figure per theme.
```{r, warning = FALSE, messages = FALSE, cache = TRUE}
# Set up the data with only aggregate values
    oneyear <- c("Fisheries health index")
    surveyindicators <- c("All 5 food groups", "Child labor", 
                          "Female landholdings", 
                          "Minimum dietary diversity, child",                   
                          "Minimum dietary diversity, women", "NCD-Protect",
                          "NCD-Risk", "Reduced coping strategies",
                          "Social protection adequacy", 
                          "Social protection coverage", 
                          "Soft drink consumption", 
                          "Zero fruits or vegetables, adult", 
                          "Zero fruits or vegetables, child",
                          "Protective foods",
                          "Dietary moderation")

  data <- FSCI_2025 %>%
    filter(!(unit == "categorical")) %>%
    filter(!(is.na(indicator_order))) %>%
    # Eliminate survey indicators
    filter(!(short_label %in% surveyindicators)) %>%
    select(c(desirable_direction, year, short_label, indicator_order, regionmean, FSCI_region, incomegrpmean, income_group, globalmean, theme)) %>% unique() %>%
    arrange(indicator_order, year) %>%
    mutate(year = as.factor(year)) %>%
    rename('Global mean' = globalmean)
  data <- droplevels(data)
  data$short_label <- factor(data$short_label)
  data <- data %>% droplevels()
  
  # Order themes
  data$theme <- ordered(data$theme, levels = c("Diets, Nutrition, and Health", "Environment, natural resources, and production", "Livelihoods, Poverty, and Equity", "Governance", "Resilience"))

# Income group and metadata table
    incomegroups <- data %>%
      select(-c("FSCI_region", "regionmean")) %>%
      unique() %>%
      filter(!(is.na(income_group))) %>%
      pivot_wider(names_from = income_group, values_from = incomegrpmean) %>%
      arrange(indicator_order) %>%
      relocate('Global mean', .after = 'High income') %>%
      relocate('Upper middle income', .after = 'Lower middle income') %>%
      pivot_longer(6:10, names_to = "group", values_to = "value")
    incomegroups <- droplevels(incomegroups)

# Plot function
    plotlines <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = FALSE) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(size = 5, angle = 45),
                plot.title = element_text(size = 8)) +
          ggtitle(x) 
      print(p)
    }

# Run for all indicators    
  ordered_indicators <- fct_reorder(data$short_label, data$indicator_order)
  indicators <- as.list(levels(ordered_indicators))
  lapply(indicators, function(x) plotlines(incomegroups, x, income_colors))
    
# Plot per theme - income
  n <- 1
  for (i in levels(data$theme)) {
    df <- paste0("df_", n)  
    assign(df, incomegroups %>%
             filter(theme == i) %>%
             mutate(short_label = as.factor(short_label),
                    year = as.factor(year)) %>%
             droplevels() %>%
             arrange(short_label, year, group)) 
    ordered_indicators <- fct_reorder(get(df)$short_label, get(df)$indicator_order)
    ind <- paste0("indicators_", n)  
    assign(ind, as.list(levels(ordered_indicators)))
    n <- n + 1
  }
    
  # Now run for all the indicators per theme
    plots_1 <- lapply(indicators_1, function(x) plotlines(df_1, x, income_colors)) 
    plots_2 <- lapply(indicators_2, function(x) plotlines(df_2, x, income_colors)) 
    plots_3 <- lapply(indicators_3, function(x) plotlines(df_3, x, income_colors)) 
    plots_4 <- lapply(indicators_4, function(x) plotlines(df_4, x, income_colors)) 
    plots_5 <- lapply(indicators_5, function(x) plotlines(df_5, x, income_colors))
  
# Set up a figure for the legend
  forlegend <- function(data, x, colors) {
        p <- data %>% 
          filter(short_label == x) %>%
          arrange(indicator_order, year) %>%
          ggplot(aes(x = year, y = value, group = group)) +
          geom_point(aes(color = group)) + 
          geom_line(aes(color = group), size = 0.5) + 
          scale_color_manual(values = colors) +
          guides(color = guide_legend()) +
          theme_classic() +
          theme(axis.title.x = element_blank(),
                axis.title.y = element_blank(),
                axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
                plot.title = element_text(size = 8),
                legend.text = element_text(size=8),
                legend.title.align = 0,
                legend.position = "right", 
                legend.justification = "left",
                legend.direction = "horizontal",
                legend.title = element_blank()) +
          ggtitle(x) 
      print(p)
  }
  for_legend <- lapply(indicators_5, function(x) forlegend(df_5, x, income_colors))
  legend <- get_legend(for_legend[[1]])
  
  # Combine the figures per indicator into a single plot per theme
    p1 <- cowplot::plot_grid(plotlist = plots_1, ncol = 3, align = 'v')
    p2 <- cowplot::plot_grid(plotlist = plots_2, ncol = 3, align = 'v')
    p3 <- cowplot::plot_grid(plotlist = plots_3, ncol = 2, align = 'v')
    p4 <- cowplot::plot_grid(plotlist = plots_4, ncol = 2, align = 'v')
    p5 <- cowplot::plot_grid(plotlist = plots_5, ncol = 2, align = 'v')
  
  # Add legend and save figure
    png(file.path(figtab_out, "SI Figure X_Theme1_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p1,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme2_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p2,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme3_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p3,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme4_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p4,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()
    png(file.path(figtab_out, "SI Figure X_Theme5_income.png"), width = 7.5, height = 10, unit = "in", res = 300)
      cowplot::plot_grid(p5,legend, nrow = 2, rel_heights = c(22,1), align = "hv")
      dev.off()

  # Clean up
    rm(incomegroups, data, for_legend, indicators, legend)
    for (i in 1:5) {
      if (exists(paste0("df_", i))) {
        rm(list = paste0("df_", i), envir = .GlobalEnv)
      }
     if (exists(paste0("plots_", i))) {
        rm(list = paste0("plots_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("indicators_", i))) {
        rm(list = paste0("indicators_", i), envir = .GlobalEnv)
      }
      if (exists(paste0("p", i))) {
        rm(list = paste0("p", i), envir = .GlobalEnv)
      }
    }

```

#### Supplementary Data 1: Metadata and Codebook Latest data point per indicator
This code creates the table that lists the latest data point per country-indicator pair
```{r, warning = FALSE, messages = FALSE, echo = TRUE}
  # Latest data point
    latest_df <- FSCI_2025 %>%
      filter(!(is.na(value))) %>%
      group_by(country, indicator) %>%
      mutate(maxyear = max(year)) %>%
      ungroup() %>%
      filter(year == maxyear) %>%
      sort_by(country ~ indicator_order) 

  # To fix indicator column ordering
    indicator_order <- latest_df %>% 
      select(c(short_label, indicator_order)) %>%
      unique()
    # Create a complete list by country
    complete_grid <- latest_df %>%
      select(c(country)) %>% unique()
    complete_grid <- merge(complete_grid, indicator_order) %>%
      arrange(country, indicator_order)
    
    for_metadata <- latest_df %>%
      select(c(1,5,9)) 
    for_metadata <- left_join(complete_grid, for_metadata, by = c("country", "short_label"))

  for_metadata <- for_metadata %>%
    select(-c(indicator_order)) %>%
    pivot_wider(names_from = short_label, values_from = year) %>%
    mutate(across(c(2:58), as.character),
           across(c(2:58), na_if, "NA"))
  writexl::write_xlsx(for_metadata, file.path(data_out, "Latest data point per country-indicator.xlsx"))
  # This sheet is manually added to Supplementary Data 1 - Metadata and Codebook 
```

